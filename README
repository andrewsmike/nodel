Nodel
=====

Nodel is a toy language aimed at visually representing datastructures and algorithms.
You can find details about the architecture in ARCH.

Building
--------
make directives:
- all: Build test application.
- clean: Clean all files.

Usage
-----
Nodel currently produces two executables.
./test is for testing various modules of code, and has many special purpose arguments.
./nodel is for loading a serialized graph from a file and executing the included program, with args.
Type ./nodel for help.

Status
------
Nodel currently has a working node graph with backreferences and garbage collection.
It includes a frequency and event based runtime system, along with an interpreter and
assembler. Nodel was not made to be inefficient, but with the exception of nodepool
(replacement in progress), nodel runs with reasonable efficiency. (Nodepool shall be
obliterated with the fury of a thousand daemons.) The runtime is partially complete,
and requires more testing/debugging/refactoring/feature adding before being ready for
use. Nodel is now able to run programs generated from a basic assembly language.

Future work
-----------
- Obliviate nodepool (replace with multiple slab hashtable pools for nodes)
- Modify opcodes to accept constants, have branch default to next
- Continue work on the runtime systems
- - Break into multiple files and refactor
- - Add occasional GC call somewhere
- - Add excall hook and registry system
- - Debug and test like hell
- - Heavy performance analysis (how slow are waittables?)
- Clean up and refactor assembler source some more
- Graph_dcopy functionality
- Storage excalls using ^graph_dcopy
- Assembly differ for visualizations
- Toy assembler command, toy interpreter command
- Possible optimizations to hashing function? (fastpath/shift for cap==2<<n?)
- Refactor codebase with consistent style (naming, whitespace, struct members, etc)
- Process management excalls?
- Features for embedding into games (limits on process count, frequency, nodecount, etc)
- Further performance analysis
- Runtime serialization (possibly just encode into graph, save graph and root)
- Add in-place usage of datastructures where applicable
- BASIC-inspired datastructure oriented high level language compiler (and utilities)
- graph <---> assembly tools
- NCURSES test visualization interface.
- Actual GUI (What to use, oh god... xlib? gtk? pygame? cat > /dev/printer?)

Goals
-----
The goal of this project is to build a virtual environment where users are able to manipulate
running processes and their datastructures in realtime. The idea came from a discussion with
friends about how programming systems embedded into sandbox games should work.