Nodel
=====

Nodel is a toy language aimed at visually representing datastructures and algorithms.
You can find details about the architecture in ARCH.

Building
--------
make directives:
- all: Build test application.
- clean: Clean all files.

Usage
-----
Nodel currently produces two executables.
./test is for testing various modules of code, and has many special purpose arguments.
./nodel is for loading a serialized graph from a file and executing the included program, with args.
Type ./nodel for help.

Status
------
Nodel currently has a working node graph with backreferences and garbage collection.
It includes a frequency and event based runtime system, along with an interpreter and
assembler. Nodel was not made to be inefficient, but with the exception of nodepool
(replacement in progress), nodel runs with reasonable efficiency. (Nodepool shall be
obliterated with the fury of a thousand daemons.) The runtime is partially complete,
and requires more testing/debugging/refactoring/feature adding before being ready for
use. Nodel is now able to run programs generated from a basic assembly language.

Future work
-----------
- Obliviate nodepool (replace with multiple slab hashtable pools for nodes)
- Modify branch default to instpntr.next, verify constants in opcodes.
- Continue work on the runtime systems
- - Break into multiple files and refactor
- - Better tools for debugging specific processes (process error message, error state)
- - Add occasional GC call somewhere
- - Add excall hook and registry system
- - - Process management excalls?
- - Debug and test like hell
- - Heavy performance analysis (how slow are waittables?)
- - Runtime serialization (possibly just encode into graph, save graph and root)
- Graph_dcopy functionality
- - Toy assembler command
- - Storage excalls (dcopy) (excalls)
- Toy interpreter command
- Assembly differ for visualizations
- Recursive resizable hashtable for efficient node ID -> *hashtable lookup.
- - Or fancy lazy copy/growth hashtable
- Refactor codebase with consistent style (naming, whitespace, struct members, etc)
- Features for embedding into games (limits on process count, frequency, nodecount, etc)
- Further performance analysis
- Further tests
- Basic vector container
- - Move heap to vector implementation
- Improve testing system and refactor tests.
- BASIC-inspired datastructure oriented high level language compiler (and utilities)
- graph <---> assembly tools
- NCURSES test visualization interface.
- Actual GUI (What to use, oh god... xlib? gtk? pygame? cat > /dev/printer?)

Goals
-----
The goal of this project is to build a virtual environment where users are able to manipulate
running processes and their datastructures in realtime. The idea came from a discussion with
friends about how programming systems embedded into sandbox games should work.